#pragma once
class ProcessorStats
{
public:
	ProcessorStats(void);
	~ProcessorStats(void);
private:
	
	//PListType memoryCeiling;
	//double mostMemoryOverflow;
	//double currMemoryOverflow;
	//vector<mutex*> gatedMutexes;
	//vector<unsigned int> currentLevelVector;
	//vector<bool> activeThreads;
	//int threadsDispatched;
	//int threadsDefuncted;
	//vector<future<void>> *threadPool;
	//vector<future<void>> *threadPlantSeedPoolHD;
	//vector<future<void>> *threadPlantSeedPoolRAM;
	//std::string::size_type sz;
	//PListType memoryPerThread;
	//unsigned int globalLevel;
	////If /c is in commands then cycle from 1 thread to MAX threads on machine and output best thread scheme
	//mutex *countMutex;
	//vector<vector<string>> prevFileNameList;
	//vector<vector<string>> newFileNameList;
	//queue<string> filesToBeRemoved;
	//mutex filesToBeRemovedLock;
	//double MemoryUsedPriorToThread;
	//double MemoryUsageAtInception;
	//vector<bool> usedRAM;
	//vector<vector<PListType>*>* prevPListArray;
	//vector<vector<PListType>*>* globalPListArray;
	//PListType eradicatedPatterns;
	//vector<PListType> levelRecordings;
	//vector<PListType> mostCommonPatternCount;
	//vector<PListType> mostCommonPatternIndex;
	//StopWatch initTime;
	//bool processingFinished;
	//bool processingMSYNCFinished;
	//bool writingFlag;
	//vector<float> coverage;
	//map<unsigned int, unsigned int> chunkIndexToFileChunk;
	//vector<string> fileChunks;
	//vector<double> statisticsModel;
	//vector<double> processingTimes;
	//map<PListType, PListType> finalPattern;
	//bool firstLevelProcessedHD;

};

